var searchIndex = {};
searchIndex["m3u8_rs"] = {"doc":"A library to parse m3u8 playlists (HTTP Live Streaming) link.","items":[[4,"MasterPlaylistTag","m3u8_rs","Contains all the tags required to parse a master playlist.",null,null],[13,"M3U","","",0,null],[13,"Version","","",0,null],[13,"VariantStream","","",0,null],[13,"AlternativeMedia","","",0,null],[13,"SessionData","","",0,null],[13,"SessionKey","","",0,null],[13,"Start","","",0,null],[13,"IndependentSegments","","",0,null],[13,"Unknown","","",0,null],[13,"Comment","","",0,null],[13,"Uri","","",0,null],[4,"MediaPlaylistTag","","Contains all the tags required to parse a media playlist.",null,null],[13,"M3U","","",1,null],[13,"Version","","",1,null],[13,"Segment","","",1,null],[13,"TargetDuration","","",1,null],[13,"MediaSequence","","",1,null],[13,"DiscontinuitySequence","","",1,null],[13,"EndList","","",1,null],[13,"PlaylistType","","",1,null],[13,"IFramesOnly","","",1,null],[13,"Start","","",1,null],[13,"IndependentSegments","","",1,null],[4,"SegmentTag","","All possible media segment tags.",null,null],[13,"Extinf","","",2,null],[13,"ByteRange","","",2,null],[13,"Discontinuity","","",2,null],[13,"Key","","",2,null],[13,"Map","","",2,null],[13,"ProgramDateTime","","",2,null],[13,"DateRange","","",2,null],[13,"Unknown","","",2,null],[13,"Comment","","",2,null],[13,"Uri","","",2,null],[5,"parse_playlist","","Parse a m3u8 playlist.",null,null],[5,"parse_playlist_res","","Parse a m3u8 playlist just like `parse_playlist`. This returns a Result<PLaylist,_>.",null,null],[5,"parse_master_playlist","","Parse input as a master playlist",null,null],[5,"parse_master_playlist_res","","Parse input as a master playlist",null,null],[5,"parse_media_playlist","","Parse input as a media playlist",null,null],[5,"parse_media_playlist_res","","Parse input as a media playlist",null,null],[5,"is_master_playlist","","When a media tag or no master tag is found, this returns false.",null,null],[5,"contains_master_tag","","Scans input looking for either a master or media `#EXT` tag.",null,null],[5,"is_master_playlist_tag_line","","",null,null],[5,"parse_master_playlist_tags","","",null,null],[5,"master_playlist_tag","","",null,null],[5,"variant_stream_tag","","",null,null],[5,"variant_i_frame_stream_tag","","",null,null],[5,"alternative_media_tag","","",null,null],[5,"session_data_tag","","",null,null],[5,"session_key_tag","","",null,null],[5,"parse_media_playlist_tags","","",null,null],[5,"media_playlist_tag","","",null,null],[5,"playlist_type","","",null,null],[5,"media_segment_tag","","",null,null],[5,"duration_title_tag","","",null,null],[5,"key","","",null,null],[5,"map","","",null,null],[5,"m3u_tag","","",null,null],[5,"version_tag","","",null,null],[5,"start_tag","","",null,null],[5,"ext_tag","","",null,null],[5,"comment_tag","","",null,null],[5,"key_value_pairs","","",null,null],[5,"key_value_pair","","",null,null],[5,"quoted","","",null,null],[5,"unquoted","","",null,null],[5,"consume_line","","",null,null],[5,"number","","",null,null],[5,"byte_range_val","","",null,null],[5,"float","","",null,null],[5,"from_utf8_slice","","",null,null],[5,"from_utf8_slice2","","",null,null],[0,"playlist","","Contains all the structs used for parsing.",null,null],[3,"MasterPlaylist","m3u8_rs::playlist","A Master Playlist provides a set of Variant Streams, each of which describes a different version of the same content.",null,null],[12,"version","","",3,null],[12,"variants","","",3,null],[12,"session_data","","",3,null],[12,"session_key","","",3,null],[12,"start","","",3,null],[12,"independent_segments","","",3,null],[3,"VariantStream","","`#EXT-X-STREAM-INF:<attribute-list>   <URI>` `#EXT-X-I-FRAME-STREAM-INF:<attribute-list>`",null,null],[12,"is_i_frame","","",4,null],[12,"uri","","",4,null],[12,"bandwidth","","",4,null],[12,"average_bandwidth","","",4,null],[12,"codecs","","",4,null],[12,"resolution","","",4,null],[12,"frame_rate","","",4,null],[12,"audio","","",4,null],[12,"video","","",4,null],[12,"subtitles","","",4,null],[12,"closed_captions","","",4,null],[12,"alternatives","","",4,null],[3,"AlternativeMedia","","`#EXT-X-MEDIA:<attribute-list>`",null,null],[12,"media_type","","",5,null],[12,"uri","","",5,null],[12,"group_id","","",5,null],[12,"language","","",5,null],[12,"assoc_language","","",5,null],[12,"name","","",5,null],[12,"default","","",5,null],[12,"autoselect","","",5,null],[12,"forced","","",5,null],[12,"instream_id","","",5,null],[12,"characteristics","","",5,null],[3,"SessionKey","","`#EXT-X-SESSION-KEY:<attribute-list>`",null,null],[12,"0","","",6,null],[3,"SessionData","","`#EXT-X-SESSION-DATA:<attribute-list>` The EXT-X-SESSION-KEY tag allows encryption keys from Media Playlists to be specified in a Master Playlist.  This allows the client to preload these keys without having to read the Media Playlist(s) first.",null,null],[12,"data_id","","",7,null],[12,"value","","",7,null],[12,"uri","","",7,null],[12,"language","","",7,null],[3,"MediaPlaylist","","A Media Playlist contains a list of Media Segments, which when played sequentially will play the multimedia presentation.",null,null],[12,"version","","",8,null],[12,"target_duration","","`#EXT-X-TARGETDURATION:<s>`",8,null],[12,"media_sequence","","`#EXT-X-MEDIA-SEQUENCE:<number>`",8,null],[12,"segments","","",8,null],[12,"discontinuity_sequence","","`#EXT-X-DISCONTINUITY-SEQUENCE:<number>`",8,null],[12,"end_list","","`#EXT-X-ENDLIST`",8,null],[12,"playlist_type","","`#EXT-X-PLAYLIST-TYPE`",8,null],[12,"i_frames_only","","`#EXT-X-I-FRAMES-ONLY`",8,null],[12,"start","","`#EXT-X-START`",8,null],[12,"independent_segments","","`#EXT-X-INDEPENDENT-SEGMENTS`",8,null],[3,"MediaSegment","","A Media Segment is specified by a URI and optionally a byte range.",null,null],[12,"uri","","",9,null],[12,"duration","","`#EXTINF:<duration>,[<title>]`",9,null],[12,"title","","`#EXTINF:<duration>,[<title>]`",9,null],[12,"byte_range","","`#EXT-X-BYTERANGE:<n>[@<o>]`",9,null],[12,"discontinuity","","`#EXT-X-DISCONTINUITY`",9,null],[12,"key","","`#EXT-X-KEY:<attribute-list>`",9,null],[12,"map","","`#EXT-X-MAP:<attribute-list>`",9,null],[12,"program_date_time","","`#EXT-X-PROGRAM-DATE-TIME:<YYYY-MM-DDThh:mm:ssZ>`",9,null],[12,"daterange","","`#EXT-X-DATERANGE:<attribute-list>`",9,null],[3,"Key","","`#EXT-X-KEY:<attribute-list>`",null,null],[12,"method","","",10,null],[12,"uri","","",10,null],[12,"iv","","",10,null],[12,"keyformat","","",10,null],[12,"keyformatversions","","",10,null],[3,"Map","","`#EXT-X-MAP:<attribute-list>`",null,null],[12,"uri","","",11,null],[12,"byte_range","","",11,null],[3,"ByteRange","","`#EXT-X-BYTERANGE:<n>[@<o>]`",null,null],[12,"length","","",12,null],[12,"offset","","",12,null],[3,"DateRange","","`#EXT-X-DATERANGE:<attribute-list>`",null,null],[12,"id","","",13,null],[12,"class","","",13,null],[12,"start_date","","",13,null],[12,"end_date","","",13,null],[12,"duration","","",13,null],[12,"planned_duration","","",13,null],[12,"x_prefixed","","",13,null],[12,"end_on_next","","",13,null],[3,"Start","","`#EXT-X-START:<attribute-list>`",null,null],[12,"time_offset","","",14,null],[12,"precise","","",14,null],[3,"ExtTag","","A simple `#EXT-` tag",null,null],[12,"tag","","",15,null],[12,"rest","","",15,null],[4,"Playlist","","Playlist, can either be a `MasterPlaylist` or a `MediaPlaylist`.",null,null],[13,"MasterPlaylist","","",16,null],[13,"MediaPlaylist","","",16,null],[4,"AlternativeMediaType","","",null,null],[13,"Audio","","",17,null],[13,"Video","","",17,null],[13,"Subtitles","","",17,null],[13,"ClosedCaptions","","",17,null],[4,"MediaPlaylistType","","`#EXT-X-PLAYLIST-TYPE:<EVENT|VOD>`",null,null],[13,"Event","","",18,null],[13,"Vod","","",18,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"playlist"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"playlist"}],"output":{"name":"bool"}}],[11,"write_to","","",16,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"masterplaylist"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"masterplaylist"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"masterplaylist"}],"output":{"name":"bool"}}],[11,"from_tags","","",3,{"inputs":[{"name":"vec"}],"output":{"name":"masterplaylist"}}],[11,"write_to","","",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"variantstream"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"variantstream"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"variantstream"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",4,{"inputs":[{"name":"hashmap"},{"name":"bool"}],"output":{"name":"variantstream"}}],[11,"write_to","","",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"alternativemedia"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"alternativemedia"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"alternativemedia"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",5,{"inputs":[{"name":"hashmap"}],"output":{"name":"alternativemedia"}}],[11,"write_to","","",5,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"alternativemediatype"}],"output":{"name":"bool"}}],[11,"from_str","","",17,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"default","","",17,{"inputs":[],"output":{"name":"alternativemediatype"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"sessionkey"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"sessionkey"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"sessionkey"}],"output":{"name":"bool"}}],[11,"write_to","","",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",7,{"inputs":[],"output":{"name":"sessiondata"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"sessiondata"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"sessiondata"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",7,{"inputs":[{"name":"hashmap"}],"output":{"name":"sessiondata"}}],[11,"write_to","","",7,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",8,{"inputs":[],"output":{"name":"mediaplaylist"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"mediaplaylist"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"mediaplaylist"}],"output":{"name":"bool"}}],[11,"from_tags","","",8,{"inputs":[{"name":"vec"}],"output":{"name":"mediaplaylist"}}],[11,"write_to","","",8,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"mediaplaylisttype"}],"output":{"name":"bool"}}],[11,"from_str","","",18,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",18,{"inputs":[],"output":{"name":"mediaplaylisttype"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",9,{"inputs":[],"output":{"name":"mediasegment"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"mediasegment"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"mediasegment"}],"output":{"name":"bool"}}],[11,"empty","","",9,{"inputs":[],"output":{"name":"mediasegment"}}],[11,"write_to","","",9,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",10,{"inputs":[],"output":{"name":"key"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"key"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"key"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"key"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",10,{"inputs":[{"name":"hashmap"}],"output":{"name":"key"}}],[11,"write_attributes_to","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"map"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",11,{"inputs":[{"name":"hashmap"}],"output":{"name":"map"}}],[11,"write_attributes_to","","",11,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"byterange"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"byterange"}}],[11,"eq","","",12,{"inputs":[{"name":"self"},{"name":"byterange"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"self"},{"name":"byterange"}],"output":{"name":"bool"}}],[11,"write_value_to","","",12,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"from","","",12,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",12,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"daterange"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"daterange"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"daterange"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",14,{"inputs":[],"output":{"name":"start"}}],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"start"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"self"},{"name":"start"}],"output":{"name":"bool"}}],[11,"from_hashmap","","",14,{"inputs":[{"name":"hashmap"}],"output":{"name":"start"}}],[11,"write_to","","",14,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"exttag"}}],[11,"fmt","m3u8_rs","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[4,"MasterPlaylistTag"],[4,"MediaPlaylistTag"],[4,"SegmentTag"],[3,"MasterPlaylist"],[3,"VariantStream"],[3,"AlternativeMedia"],[3,"SessionKey"],[3,"SessionData"],[3,"MediaPlaylist"],[3,"MediaSegment"],[3,"Key"],[3,"Map"],[3,"ByteRange"],[3,"DateRange"],[3,"Start"],[3,"ExtTag"],[4,"Playlist"],[4,"AlternativeMediaType"],[4,"MediaPlaylistType"]]};
searchIndex["nom"] = {"doc":"nom, eating data byte by byte","items":[[3,"ProducerRepeat","nom","ProducerRepeat takes a single value, and generates it at each step",null,null],[3,"MemProducer","","A MemProducer generates values from an in memory byte buffer",null,null],[3,"FileProducer","","",null,null],[3,"MapConsumer","","MapConsumer takes a function S -> T and applies it on a consumer producing values of type S",null,null],[3,"ChainConsumer","","ChainConsumer takes a consumer C1 R -> S, and a consumer C2 S -> T, and makes a consumer R -> T by applying C2 on C1's result",null,null],[4,"ErrorKind","","indicates which parser returned an error",null,null],[13,"Custom","","",0,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many0","","",0,null],[13,"Many1","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"HexDigit","","",0,null],[13,"OctDigit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[13,"Switch","","",0,null],[13,"TagBits","","",0,null],[13,"OneOf","","",0,null],[13,"NoneOf","","",0,null],[13,"Char","","",0,null],[13,"CrLf","","",0,null],[13,"RegexpMatch","","",0,null],[13,"RegexpMatches","","",0,null],[13,"RegexpFind","","",0,null],[13,"RegexpCapture","","",0,null],[13,"RegexpCaptures","","",0,null],[13,"TakeWhile1","","",0,null],[13,"Complete","","",0,null],[13,"Fix","","",0,null],[13,"Escaped","","",0,null],[13,"EscapedTransform","","",0,null],[13,"TagStr","","",0,null],[13,"IsNotStr","","",0,null],[13,"IsAStr","","",0,null],[13,"TakeWhile1Str","","",0,null],[13,"NonEmpty","","",0,null],[13,"ManyMN","","",0,null],[13,"TakeUntilAndConsumeStr","","",0,null],[13,"TakeUntilStr","","",0,null],[4,"Err","","Contains the error that a parser can return",null,null],[13,"Code","","An error code, represented by an ErrorKind, which can contain a custom error code represented by E",1,null],[13,"Node","","An error code, and the next error",1,null],[13,"Position","","An error code, and the input position",1,null],[13,"NodePosition","","An error code, the input position and the next error",1,null],[4,"Needed","","Contains information on needed data if a parser returned `Incomplete`",null,null],[13,"Unknown","","needs more data, but we do not know how much",2,null],[13,"Size","","contains the required data size",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","indicates a correct parsing, the first field containing the rest of the unparsed data, the second field contains the parsed data",3,null],[13,"Error","","contains a Err, an enum that can indicate an error code, a position in the input, and a pointer to another error, making a list of errors in the parsing tree",3,null],[13,"Incomplete","","Incomplete contains a Needed, an enum than can represent a known quantity of input data, or unknown",3,null],[4,"Input","","",null,null],[13,"Element","","",4,null],[13,"Empty","","",4,null],[13,"Eof","","",4,null],[4,"ConsumerState","","Stores a consumer's current computation state",null,null],[13,"Done","","A value of type O has been produced",5,null],[13,"Error","","An error of type E has been encountered",5,null],[13,"Continue","","Continue applying, and pass a message of type M to the data source",5,null],[4,"Move","","",null,null],[13,"Consume","","indcates how much data was consumed",6,null],[13,"Seek","","indicates where in the input the consumer must seek",6,null],[13,"Await","","indicates more data is needed",6,null],[4,"FileProducerState","","",null,null],[13,"Normal","","",7,null],[13,"Error","","",7,null],[13,"Eof","","",7,null],[5,"error_to_list","","",null,{"inputs":[{"name":"err"}],"output":{"name":"vec"}}],[5,"compare_error_paths","","",null,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[5,"add_error_pattern","","",null,{"inputs":[{"name":"hashmap"},{"name":"iresult"},{"name":"str"}],"output":{"name":"bool"}}],[5,"slice_to_offsets","","",null,null],[5,"prepare_errors","","",null,null],[5,"print_error","","",null,null],[5,"generate_colors","","",null,null],[5,"code_from_offset","","",null,null],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"print_offsets","","",null,null],[5,"error_to_u32","","",null,{"inputs":[{"name":"errorkind"}],"output":{"name":"u32"}}],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"not_line_ending","","",null,null],[5,"line_ending","","Recognizes a line feed",null,null],[5,"is_alphabetic","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_oct_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"digit","","Recognizes numerical characters: 0-9",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"hex_digit","","Recognizes hexadecimal numerical characters: 0-9, A-F, a-f",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"oct_digit","","Recognizes octal characters: 0-7",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"space","","Recognizes spaces and tabs",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"sized_buffer","","",null,null],[5,"length_value","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"hex_u32","","Recognizes a hex-encoded integer",null,null],[5,"eof","","Recognizes empty input buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"non_empty","","Recognizes non empty buffers",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"rest","","Return the remaining input.",null,null],[5,"newline","","",null,null],[5,"crlf","","",null,null],[5,"eol","","",null,null],[5,"tab","","",null,null],[5,"anychar","","",null,null],[5,"shift","","",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"description","","",0,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"err"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"err"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"err"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"needed"}}],[11,"is_known","","",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"map","","Maps a `Needed` to `Needed` by appling a function to a contained `Size` value.",2,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"needed"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"iresult"}}],[11,"is_done","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_err","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_incomplete","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"map","","Maps a `IResult<I, O, E>` to `IResult<I, N, E>` by appling a function to a contained `Done` value, leaving `Error` and `Incomplete` value untouched.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"iresult"}}],[11,"map_inc","","Maps a `IResult<I, O, E>` to `IResult<I, O, E>` by appling a function to a contained `Incomplete` value, leaving `Done` and `Error` value untouched.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"iresult"}}],[11,"map_err","","Maps a `IResult<I, O, E>` to `IResult<I, O, N>` by appling a function to a contained `Error` value, leaving `Done` and `Incomplete` value untouched.",3,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"iresult"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"description","","",1,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"input"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"consumerstate"}}],[11,"map","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"consumerstate"}}],[11,"flat_map","","",5,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"consumerstate"}}],[11,"apply","","",8,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"consumerstate"}}],[11,"new","","",9,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"move"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"move"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"move"}],"output":{"name":"bool"}}],[11,"apply","","",9,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"consumerstate"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"fileproducerstate"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"fileproducerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",10,{"inputs":[{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"state","","",10,{"inputs":[{"name":"self"}],"output":{"name":"fileproducerstate"}}],[11,"refill","","",10,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"resize","","Resize the internal buffer, copy the data to the new one and returned how much data was copied",10,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"apply","","",10,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"consumerstate"}}],[11,"new","","",11,{"inputs":[{"name":"c"},{"name":"f"}],"output":{"name":"mapconsumer"}}],[11,"handle","","",11,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"consumerstate"}}],[11,"state","","",11,{"inputs":[{"name":"self"}],"output":{"name":"consumerstate"}}],[11,"new","","",12,{"inputs":[{"name":"c1"},{"name":"c2"}],"output":{"name":"chainconsumer"}}],[11,"handle","","",12,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"consumerstate"}}],[11,"state","","",12,{"inputs":[{"name":"self"}],"output":{"name":"consumerstate"}}],[8,"HexDisplay","","useful functions to calculate the offset between slices and show a hexdump of a slice",null,null],[10,"offset","","offset between the first byte of self and the first byte of the argument",13,null],[10,"to_hex","","Converts the value of `self` to a hex dump, returning the owned string.",13,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"string"}}],[10,"to_hex_from","","Converts the value of `self` to a hex dump beginning at `from` address, returning the owned string.",13,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"string"}}],[8,"InputLength","","",null,null],[10,"input_len","","",14,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[8,"AsChar","","",null,null],[10,"as_char","","",15,{"inputs":[{"name":"self"}],"output":{"name":"char"}}],[10,"is_alpha","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_alphanum","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_0_to_9","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_hex_digit","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_oct_digit","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[8,"IterIndices","","",null,null],[16,"Item","","",16,null],[16,"Iter","","",16,null],[10,"iter_indices","","",16,null],[8,"AsBytes","","",null,null],[10,"as_bytes","","",17,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"GetOutput","","",null,null],[10,"output","","",19,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"Consumer","","The Consumer trait wraps a computation and its state",null,null],[10,"handle","","implement handle for the current computation, returning the new state of the consumer",20,{"inputs":[{"name":"self"},{"name":"input"}],"output":{"name":"consumerstate"}}],[10,"state","","returns the current state",20,{"inputs":[{"name":"self"}],"output":{"name":"consumerstate"}}],[8,"Producer","","The producer wraps a data source, like file or network, and applies a consumer on it",null,null],[10,"apply","","Applies a consumer once on the produced data, and return the consumer's state",21,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"consumerstate"}}],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",21,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"option"}}],[14,"dbg","","Prints a message if the parser fails",null,null],[14,"dbg_dmp","","Prints a message and the input if the parser fails",null,null],[14,"closure","","Wraps a parser in a closure",null,null],[14,"named","","Makes a function from a parser combination",null,null],[14,"call","","Used to wrap common expressions and function as macros",null,null],[14,"apply","","emulate function currying: `apply!(my_function, arg1, arg2, ...)` becomes `my_function(input, arg1, arg2, ...)`",null,null],[14,"error","","Prevents backtracking if the child parser fails",null,null],[14,"add_error","","Add an error if the child parser fails",null,null],[14,"fix_error","","translate parser result from IResult<I,O,u32> to IResult<I,O,E> with a custom type",null,null],[14,"complete","","replaces a `Incomplete` returned by the child parser with an `Error`",null,null],[14,"try_parse","","A bit like `std::try!`, this macro will return the remaining input and parsed value if the child parser returned `Done`, and will do an early return for `Error` and `Incomplete` this can provide more flexibility than `chain!` if needed",null,null],[14,"flat_map","","`flat_map!(R -> IResult<R,S>, S -> IResult<S,T>) => R -> IResult<R, T>`",null,null],[14,"map","","`map!(I -> IResult<I,O>, O -> P) => I -> IResult<I, P>` maps a function on the result of a parser",null,null],[14,"map_res","","`map_res!(I -> IResult<I,O>, O -> Result<P>) => I -> IResult<I, P>` maps a function returning a Result on the output of a parser",null,null],[14,"map_opt","","`map_opt!(I -> IResult<I,O>, O -> Option<P>) => I -> IResult<I, P>` maps a function returning an Option on the output of a parser",null,null],[14,"value","","`value!(T, R -> IResult<R, S> ) => R -> IResult<R, T>`",null,null],[14,"expr_res","","`expr_res!(Result<E,O>) => I -> IResult<I, O>` evaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt","","`expr_opt!(Option<O>) => I -> IResult<I, O>` evaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Some",null,null],[14,"chain","","`chain!(I->IResult<I,A> ~ I->IResult<I,B> ~ ... I->IResult<I,X> , || { return O } ) => I -> IResult<I, O>` chains parsers and assemble the results through a closure",null,null],[14,"tuple","","`tuple!(I->IResult<I,A>, I->IResult<I,B>, ... I->IResult<I,X>) => I -> IResult<I, (A, B, ..., X)>` chains parsers and assemble the sub results in a tuple.",null,null],[14,"alt","","`alt!(I -> IResult<I,O> | I -> IResult<I,O> | ... | I -> IResult<I,O> ) => I -> IResult<I, O>` try a list of parsers, return the result of the first successful one",null,null],[14,"alt_complete","","This is a combination of the `alt!` and `complete!` combinators. Rather than returning `Incomplete` on partial input, `alt_complete!` will try the next alternative in the chain. You should use this only if you know you will not receive partial input for the rules you're trying to match (this is almost always the case for parsing programming languages).",null,null],[14,"switch","","`switch!(I -> IResult<I,P>, P => I -> IResult<I,O> | ... | P => I -> IResult<I,O> ) => I -> IResult<I, O>` choose the next parser depending on the result of the first one, if successful, and returns the result of the second parser",null,null],[14,"opt","","`opt!(I -> IResult<I,O>) => I -> IResult<I, Option<O>>` make the underlying parser optional",null,null],[14,"opt_res","","`opt_res!(I -> IResult<I,O>) => I -> IResult<I, Result<nom::Err,O>>` make the underlying parser optional",null,null],[14,"cond_with_error","","`cond_with_error!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>` Conditional combinator",null,null],[14,"cond","","`cond!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>` Conditional combinator",null,null],[14,"cond_reduce","","`cond_reduce!(bool, I -> IResult<I,O>) => I -> IResult<I, O>` Conditional combinator with error",null,null],[14,"peek","","`peek!(I -> IResult<I,O>) => I -> IResult<I, O>` returns a result without consuming the input",null,null],[14,"tap","","`tap!(name: I -> IResult<I,O> => { block }) => I -> IResult<I, O>` allows access to the parser's result without affecting it",null,null],[14,"pair","","`pair!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>` pair(X,Y), returns (x,y)",null,null],[14,"separated_pair","","`separated_pair!(I -> IResult<I,O>, I -> IResult<I, T>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>` separated_pair(X,sep,Y) returns (x,y)",null,null],[14,"preceded","","`preceded!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, O>` preceded(opening, X) returns X",null,null],[14,"terminated","","`terminated!(I -> IResult<I,O>, I -> IResult<I,T>) => I -> IResult<I, O>` terminated(X, closing) returns X",null,null],[14,"delimited","","`delimited!(I -> IResult<I,T>, I -> IResult<I,O>, I -> IResult<I,U>) => I -> IResult<I, O>` delimited(opening, X, closing) returns X",null,null],[14,"separated_list","","`separated_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` separated_list(sep, X) returns Vec<X>",null,null],[14,"separated_nonempty_list","","`separated_nonempty_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` separated_nonempty_list(sep, X) returns Vec<X>",null,null],[14,"many0","","`many0!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1","","`many1!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"many_m_n","","`many_m_n!(usize, usize, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` Applies the parser between m and n times (n included) and returns the list of results in a Vec",null,null],[14,"count","","`count!(I -> IResult<I,O>, nb) => I -> IResult<I, Vec<O>>` Applies the child parser a specified number of times",null,null],[14,"count_fixed","","`count_fixed!(O, I -> IResult<I,O>, nb) => I -> IResult<I, [O; nb]>` Applies the child parser a fixed number of times and returns a fixed size array The type must be specified and it must be `Copy`",null,null],[14,"length_value","","`length_value!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>` gets a number from the first parser, then applies the second parser that many times",null,null],[14,"fold_many0","","`fold_many0!(I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser 0 or more times and folds the list of return values",null,null],[14,"fold_many1","","`fold_many1!(I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser 1 or more times and folds the list of return values",null,null],[14,"fold_many_m_n","","`fold_many_m_n!(usize, usize, I -> IResult<I,O>, R, Fn(R, O) -> R) => I -> IResult<I, R>` Applies the parser between m and n times (n included) and folds the list of return value",null,null],[14,"method","","Makes a method from a parser combination",null,null],[14,"call_m","","Used to called methods then move self back into self",null,null],[14,"apply_m","","emulate function currying for method calls on structs `apply!(self.my_function, arg1, arg2, ...)` becomes `self.my_function(input, arg1, arg2, ...)`",null,null],[14,"recognize","","`recognize!(&[T] -> IResult<&[T], O> ) => &[T] -> IResult<&[T], &[T]>` if the child parser was successful, return the consumed input as produced value",null,null],[14,"tag","","`tag!(&[T]: nom::AsBytes) => &[T] -> IResult<&[T], &[T]>` declares a byte array as a suite to recognize",null,null],[14,"is_not","","`is_not!(&[T:AsBytes]) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a","","`is_a!(&[T]) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes that appear in the provided array",null,null],[14,"escaped","","`escaped!(&[T] -> IResult<&[T], &[T]>, T, &[T] -> IResult<&[T], &[T]>) => &[T] -> IResult<&[T], &[T]>` matches a byte string with escaped characters.",null,null],[14,"escaped_transform","","`escaped_transform!(&[T] -> IResult<&[T], &[T]>, T, &[T] -> IResult<&[T], &[T]>) => &[T] -> IResult<&[T], Vec<T>>` matches a byte string with escaped characters.",null,null],[14,"take_while","","`take_while!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes until the provided function fails.",null,null],[14,"take_while1","","`take_while1!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest (non empty) list of bytes until the provided function fails.",null,null],[14,"take_till","","`take_till!(T -> bool) => &[T] -> IResult<&[T], &[T]>` returns the longest list of bytes until the provided function succeeds",null,null],[14,"take","","`take!(nb) => &[T] -> IResult<&[T], &[T]>` generates a parser consuming the specified number of bytes",null,null],[14,"take_str","","`take!(nb) => &[T] -> IResult<&[T], &str>` same as take! but returning a &str",null,null],[14,"take_until_and_consume","","`take_until_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>` generates a parser consuming bytes until the specified byte sequence is found, and consumes it",null,null],[14,"take_until","","`take_until!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data until it finds the specified tag",null,null],[14,"take_until_either_and_consume","","`take_until_either_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>` consumes data until it finds any of the specified characters, and consume it",null,null],[14,"take_until_either","","`take_until_either!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"length_bytes","","`length_bytes!(&[T] -> IResult<&[T], nb>) => &[T] -> IResult<&[T], &[T]> gets a number from the first parser, then extracts that many bytes from the remaining stream",null,null],[14,"bits","","`bits!( parser ) => ( &[u8], (&[u8], usize) -> IResult<(&[u8], usize), T> ) -> IResult<&[u8], T>` transforms its byte slice input in a bit stream for the underlying parsers",null,null],[14,"take_bits","","`take_bits!(type, nb) => ( (&[T], usize), U, usize) -> IResult<(&[T], usize), U>` generates a parser consuming the specified number of bits.",null,null],[14,"tag_bits","","matches an integer pattern to a bitstream. The number of bits of the input to compare must be specified",null,null],[14,"u16","","if parameter is true, parse a big endian u16 integer, otherwise a little endian u16 integer",null,null],[14,"u32","","if parameter is true, parse a big endian u32 integer, otherwise a little endian u32 integer",null,null],[14,"u64","","if parameter is true, parse a big endian u64 integer, otherwise a little endian u64 integer",null,null],[14,"i16","","if parameter is true, parse a big endian i16 integer, otherwise a little endian i16 integer",null,null],[14,"i32","","if parameter is true, parse a big endian i32 integer, otherwise a little endian i32 integer",null,null],[14,"i64","","if parameter is true, parse a big endian i64 integer, otherwise a little endian i64 integer",null,null],[14,"one_of","","matches one of the provided characters",null,null],[14,"none_of","","matches anything but the provided characters",null,null],[14,"char","","matches one character: `char!(char) => &[u8] -> IResult<&[u8], char>",null,null],[14,"consumer_from_parser","","",null,null],[14,"tag_s","","`tag_s!(&str) => &str -> IResult<&str, &str>` declares a string as a suite to recognize",null,null],[14,"take_s","","`take_s!(nb) => &str -> IResult<&str, &str>` generates a parser consuming the specified number of characters",null,null],[14,"is_not_s","","`is_not_s!(&str) => &str -> IResult<&str, &str>` returns the longest list of characters that do not appear in the provided array",null,null],[14,"is_a_s","","`is_a_s!(&str) => &str -> IResult<&str, &str>` returns the longest list of characters that appear in the provided array",null,null],[14,"take_while_s","","`take_while_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest list of characters until the provided function fails.",null,null],[14,"take_while1_s","","`take_while1_s!(char -> bool) => &str -> IResult<&str, &str>` returns the longest (non empty) list of characters until the provided function fails.",null,null],[14,"take_till_s","","`take_till_s!(&str -> bool) => &str -> IResult<&str, &str>` returns the longest list of characters until the provided function succeeds",null,null],[14,"take_until_and_consume_s","","`take_until_and_consume_s!(&str) => &str -> IResult<&str, &str>` generates a parser consuming all chars until the specified string is found and consumes it",null,null],[14,"take_until_s","","`take_until_s!(&str) => &str -> IResult<&str, &str>` generates a parser consuming all chars until the specified string is found and leaves it in the remaining input",null,null],[11,"run","","Applies a consumer once on the produced data, and returns the generated value if there is one",21,{"inputs":[{"name":"self"},{"name":"consumer"}],"output":{"name":"option"}}]],"paths":[[4,"ErrorKind"],[4,"Err"],[4,"Needed"],[4,"IResult"],[4,"Input"],[4,"ConsumerState"],[4,"Move"],[4,"FileProducerState"],[3,"ProducerRepeat"],[3,"MemProducer"],[3,"FileProducer"],[3,"MapConsumer"],[3,"ChainConsumer"],[8,"HexDisplay"],[8,"InputLength"],[8,"AsChar"],[8,"IterIndices"],[8,"AsBytes"],[8,"GetInput"],[8,"GetOutput"],[8,"Consumer"],[8,"Producer"]]};
initSearch(searchIndex);
