<html>
  <head>
    <style>
      body {
        margin-top: 250px;
        background-color: #121212;
        color: #ffffff;
        padding-bottom: 150px;
      }

      #ytplayer {
        margin-top: 5px;
        width: 100%;
      }

      .input-container {
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      input[type="text"] {
        width: 40%;
        height: 50px;
        font-size: 18px;
        padding: 10px;
        display: block;

        background-color: #2d2d2d;
        color: #ffffff;
        border: none;
      }

      input[type="button"] {
        width: 50%;
        height: 30px;
        font-size: 14px;
        background-color: #4e4e4e;
        color: #ffffff;
        border: none;
        cursor: pointer;
      }

      p {
        margin: 4px;
        text-align: center;
        font-size: 0.9rem;
      }

      ul {
        margin-top: 20px;
        padding: 0;
        list-style-type: none;
        text-align: center;
      }

      ul li {
        margin: 5px 0;
        font-size: 0.9rem;
        color: #cccccc;
      }
    </style>
  </head>

  <body onhashchange="onhashchange()">
    <div class="input-container">
      <input
        id="input_vid"
        type="text"
        placeholder="Video ID or URL"
        onclick="select_input_vid()"
        onkeypress="if(event.key === 'Enter') apply_input_vid_from_button()"
      />
      <button
        id="apply-vid-btn"
        onclick="apply_input_vid_from_button()"
        style="
          height: 50px;
          padding: 0 20px;
          font-size: 14px;
          background-color: #2d6a4f;
          color: #ffffff;
          border: none;
          cursor: pointer;
          border-radius: 4px;
          font-weight: bold;
          transition: background 0.2s;
        "
        onmouseover="this.style.background='#40916c';"
        onmouseout="this.style.background='#2d6a4f';"
      >Go</button>
    </div>

    <div id="parsed-url-container" style="display: none; margin: 15px 0;">
      <div style="display: flex; justify-content: center;">
        <input
          id="parsed-url"
          type="text"
          readonly
          style="
            width: 60%;
            max-width: 600px;
            padding: 8px 12px;
            background-color: #1a1a1a;
            color: #6cf06c;
            border: 1px solid #333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            text-align: center;
            cursor: pointer;
          "
          onclick="this.select(); document.execCommand('copy');"
          title="Click to copy"
        />
      </div>
    </div>

    <div id="ytplayer"></div>
    <div id="timeline-time" style="text-align:center; color:#ccc; font-size:0.95rem; margin-bottom:2px; display:flex; justify-content:center; align-items:center; gap:8px;">
      <button id="timeline-cancel-btn" title="Cancel seek" style="margin-right:8px; font-size:1.1em; display:none;">‚ùå</button>
      <span id="timeline-time-span"></span>
      <span id="timeline-drag-span" style="color:#6cf06c; display:none; margin-left:8px;"></span>
      <button id="timeline-apply-btn" title="Seek to this time" style="margin-left:8px; font-size:1.1em; display:none;">‚úÖ</button>
    </div>
    <input
      id="timeline"
      type="range"
      min="0"
      max="100"
      value="0"
      step="1"
      style="width: 100%; margin: 10px 0;"
    />

    <div style="display: flex; justify-content: center; margin: 10px 0;">
      <button
        id="play-pause-btn"
        style="
          background: #232323;
          color: #6cf06c;
          border: 1px solid #333;
          border-radius: 8px;
          font-size: 1.3rem;
          font-weight: bold;
          padding: 12px 28px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.12);
          cursor: pointer;
          transition: background 0.2s, color 0.2s;
          margin-right: 10px;
        "
        onmouseover="this.style.background='#1a1a1a';this.style.color='#fff';"
        onmouseout="this.style.background='#232323';this.style.color='#6cf06c';"
      >Play/Pause</button>
      <button
        id="switch-width-btn"
        style="
          background: #232323;
          color: #8ecae6;
          border: 1px solid #333;
          border-radius: 8px;
          font-size: 1.3rem;
          font-weight: bold;
          padding: 12px 28px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.12);
          cursor: pointer;
          transition: background 0.2s, color 0.2s;
        "
        onmouseover="this.style.background='#1a1a1a';this.style.color='#fff';"
        onmouseout="this.style.background='#232323';this.style.color='#8ecae6';"
      >Viewport</button>
    </div>

    <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; margin-top: 20px;">
      <div style="flex: 1; min-width: 300px; max-width: 600px;">
        <h3 style="text-align: center; color: #8ecae6; margin-bottom: 10px;">History</h3>
        <ul id="history_list"></ul>
        <input
          type="button"
          id="clear-history-btn"
          value="Clear History"
          onclick="clearHistory()"
          style="
            display: block;
            margin: 18px auto 10px auto;
            width: 100%;
            max-width: 480px;
            background: #232323;
            color: #ff6b6b;
            border: 1px solid #333;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
          "
          onmouseover="this.style.background='#3a2323';this.style.color='#fff';"
          onmouseout="this.style.background='#232323';this.style.color='#ff6b6b';"
        />
      </div>
      <div style="flex: 1; min-width: 300px; max-width: 600px;">
        <h3 style="text-align: center; color: #ffd166; margin-bottom: 10px;">Watch Later</h3>
        <div id="watch-later-status" style="text-align: center; color: #bbb; font-size: 0.9rem; padding: 20px;">
          Sign in to sync watch later list
        </div>
        <ul id="watch_later_list"></ul>
        <input
          type="button"
          id="refresh-watch-later-btn"
          value="Refresh Watch Later"
          onclick="loadWatchLater()"
          style="
            display: block;
            margin: 18px auto 10px auto;
            width: 100%;
            max-width: 480px;
            background: #232323;
            color: #ffd166;
            border: 1px solid #333;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
          "
          onmouseover="this.style.background='#3a3323';this.style.color='#fff';"
          onmouseout="this.style.background='#232323';this.style.color='#ffd166';"
        />
      </div>
    </div>
    <div id="msal-login-container" style="position: fixed; bottom: 16px; right: 16px; display: flex; flex-direction: column; align-items: flex-end; gap: 6px; z-index: 9999; max-width: 300px;">
      <div id="msal-user-info" style="display: none; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 10px 12px; margin-bottom: 4px; text-align: right;">
        <div id="msal-user-name" style="color: #8ecae6; font-size: 0.95rem; font-weight: 600; margin-bottom: 2px;"></div>
        <div id="msal-user-email" style="color: #bbb; font-size: 0.8rem; word-break: break-all;"></div>
      </div>
      <button id="msal-login-btn" style="background: #232323; color: #8ecae6; border: 1px solid #333; border-radius: 8px; font-size: 0.95rem; font-weight: 600; padding: 8px 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.12); cursor: pointer; transition: background 0.2s, color 0.2s;">Microsoft Sign in</button>
      <span id="msal-login-status" style="color: #bbb; font-size: 0.85rem;">Signed out</span>
    </div>
    <script>
      var tag = document.createElement("script");
      tag.src = "https://www.youtube.com/player_api";
      var firstScriptTag = document.getElementsByTagName("script")[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      var player;
      function onYouTubePlayerAPIReady() {
        console.log("onYouTubePlayerAPIReady");
        window.aaaplayer = player = new YT.Player("ytplayer", {
          height: "315",
          width: "560",
          events: {
            onReady: onPlayerReady,
            onStateChange: onPlayerStateChange,
          },
        });
      }

      var savingTimer;
      var currentPlayerState = -1;

      function onPlayerStateChange(e) {
        console.log("onPlayerStateChange", e);
        currentPlayerState = e.data;
        document.title = player.getVideoData()?.title;
        updatePlayPauseButton();

        if (e?.data === 2) {
          setTimeout(() => {
            savePosition();
          }, 2000);
        }
        if (e?.data === 1) {
          savingTimer = setInterval(() => {
            savePosition();
          }, 20000);
        } else {
          clearInterval(savingTimer);
        }
      }

      function savePosition() {
        const vid = extractYouTubeId(player.getVideoUrl());
        const pos = player.getCurrentTime();
        console.log("savePosition", pos);
        localStorage.setItem("vid-" + vid, pos);
      }

      function getPosition() {
        const vid = extractYouTubeId(player.getVideoUrl());
        return localStorage.getItem("vid-" + vid) - 0;
      }

      var timeline = document.getElementById("timeline");
      var timelineTime = document.getElementById("timeline-time");
      var timelineTimeSpan = document.getElementById("timeline-time-span");
      var timelineDragSpan = document.getElementById("timeline-drag-span");
      var timelineApplyBtn = document.getElementById("timeline-apply-btn");
      var timelineCancelBtn = document.getElementById("timeline-cancel-btn");
      var timelineDragging = false;
      var dragValue = 0;

      function formatTime(sec) {
        sec = Math.floor(sec);
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        if (h > 0) {
          return h + ":" + (m < 10 ? "0" : "") + m + ":" + (s < 10 ? "0" : "") + s;
        } else {
          return m + ":" + (s < 10 ? "0" : "") + s;
        }
      }

      function getTimeAgo(date) {
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);
        const diffDays = Math.floor(diffHours / 24);
        const diffWeeks = Math.floor(diffDays / 7);
        const diffMonths = Math.floor(diffDays / 30);
        const diffYears = Math.floor(diffDays / 365);

        if (diffSeconds < 60) return "just now";
        if (diffMinutes < 60) return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        if (diffDays < 7) return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
        if (diffWeeks < 4) return `${diffWeeks} week${diffWeeks !== 1 ? 's' : ''} ago`;
        if (diffMonths < 12) return `${diffMonths} month${diffMonths !== 1 ? 's' : ''} ago`;
        return `${diffYears} year${diffYears !== 1 ? 's' : ''} ago`;
      }

      function updateTimeline() {
        console.log("updating timeline")
        if (!player) return;
        const duration = player.getDuration();
        let current = player.getCurrentTime();
        if (duration > 0) {
          timeline.max = Math.floor(duration);
          if (!timelineDragging) {
            timeline.value = Math.floor(current);
          }
          timelineTimeSpan.textContent = formatTime(current) + " / " + formatTime(duration);
          timelineTimeSpan.style.color = "#ccc";
          if (timelineDragging) {
            timelineDragSpan.textContent = formatTime(dragValue);
            timelineDragSpan.style.display = "";
            timelineApplyBtn.style.display = "";
            timelineCancelBtn.style.display = "";
          } else {
            timelineDragSpan.textContent = "";
            timelineDragSpan.style.display = "none";
            timelineApplyBtn.style.display = "none";
            timelineCancelBtn.style.display = "none";
          }
        } else {
          timelineTimeSpan.textContent = "--:-- / --:--";
          timelineTimeSpan.style.color = "#ccc";
          timelineDragSpan.textContent = "";
          timelineDragSpan.style.display = "none";
          timelineApplyBtn.style.display = "none";
          timelineCancelBtn.style.display = "none";
        }
      }

      setInterval(updateTimeline, 500);

      timeline.addEventListener("input", function () {
        timelineDragging = true;
        dragValue = Number(timeline.value);
        updateTimeline();
      });

      timeline.addEventListener("change", function () {
        dragValue = Number(timeline.value);
        updateTimeline();
      });

      timelineApplyBtn.onclick = function() {
        if (player && player.seekTo) {
          player.seekTo(Number(dragValue), true);
        }
        timelineDragging = false;
        updateTimeline();
      };

      timelineCancelBtn.onclick = function() {
        timelineDragging = false;
        updateTimeline();
      };

      // Play/Pause button functionality
      const playPauseBtn = document.getElementById("play-pause-btn");

      function updatePlayPauseButton() {
        if (!playPauseBtn) return;

        // PlayerState: 1 = playing, 2 = paused
        if (currentPlayerState === 1) {
          playPauseBtn.textContent = "Pause";
          playPauseBtn.style.color = "#ff6b6b";
          playPauseBtn.onmouseout = function() {
            this.style.background='#232323';
            this.style.color='#ff6b6b';
          };
        } else {
          playPauseBtn.textContent = "Play";
          playPauseBtn.style.color = "#6cf06c";
          playPauseBtn.onmouseout = function() {
            this.style.background='#232323';
            this.style.color='#6cf06c';
          };
        }
      }

      playPauseBtn.onclick = function() {
        if (!player) return;

        const state = player.getPlayerState();
        if (state === 1) {
          // Currently playing, so pause
          player.pauseVideo();
        } else {
          // Currently paused or stopped, so play
          player.playVideo();
        }
      };

      function onPlayerReady() {
        console.log("onPlayerReady");
        onhashchange();
        updateTimeline();
        updatePlayPauseButton();
      }

      const history_list = document.getElementById("history_list");

      function onhashchange() {
        const vid = window.location.hash?.substring(1);
        console.log("onhashchange", vid);
        apply_vid(vid);
      }

      function startSeek(retryDelay) {
        const dur = player.getDuration();
        console.log("getDuration", dur);
        if (dur > 0) {
          const tstamp = getPosition();
          console.log("seekTo", tstamp);
          player.seekTo(tstamp, true);
        } else {
          setTimeout(() => {
            startSeek(retryDelay * 2);
          }, retryDelay);
        }
      }

      document.unload = function () {
        savePosition();
      };

      window.onbeforeunload = function () {
        savePosition();
      };

      function createCookie(name, value, days) {
        console.log("createCookie", value);
        if (days) {
          var date = new Date();
          date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
          var expires = "; expires=" + date.toGMTString();
        } else var expires = "";
        document.cookie = name + "=" + value + expires + "; path=/";
      }

      function readCookie(name) {
        const res = _readCookie(name);
        console.log("readCookie", res);
        return res;
      }

      function _readCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(";");
        for (var i = 0; i < ca.length; i++) {
          var c = ca[i];
          while (c.charAt(0) == " ") c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) == 0)
            return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      function eraseCookie(name) {
        createCookie(name, "", -1);
      }

      const input_vid = document.getElementById("input_vid");

      function select_input_vid() {
        console.log("select_input_vid");
        input_vid.value = "";
        navigator.clipboard.readText()
          .then(text => {
            input_vid.value = text
            apply_input_vid(text)
          });
      }

      function apply_input_vid(str) {
        const video_id = extractYouTubeId(str);
        if (video_id) {
          window.location.hash = "#" + video_id;
        }
      }

      function apply_input_vid_from_button() {
        const str = input_vid.value;
        if (str) {
          apply_input_vid(str);
        }
      }

      function extractYouTubeId(input) {
        try {
          // If it's already a plain video ID
          if (/^[\w-]{11}$/.test(input)) {
            return input;
          }

          const url = new URL(input);

          // Handle full or mobile YouTube URL
          if (
            url.hostname === 'www.youtube.com' ||
            url.hostname === 'm.youtube.com'
          ) {
            // Handle /live/ URLs (e.g., /live/DmiExfHEJZM)
            const liveMatch = url.pathname.match(/^\/live\/([\w-]{11})/);
            if (liveMatch) {
              return liveMatch[1];
            }

            return url.searchParams.get('v');
          }

          // Handle youtu.be short URL
          if (url.hostname === 'youtu.be') {
            return url.pathname.slice(1); // remove leading '/'
          }

        } catch (e) {
          // input is not a valid URL; fall through
        }

        return null; // couldn't extract ID
      }

      async function resolveChannelDetails(videoId) {
        try {
          const cacheKey = `channelDetails:${videoId}`;
          const cached = localStorage.getItem(cacheKey);
          if (cached) return JSON.parse(cached);
          const res = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`);
          if (res.ok) {
            const data = await res.json();
            const author_url = data.author_url || null;
            const result = { author_url };
            localStorage.setItem(cacheKey, JSON.stringify(result));
            return result;
          }
        } catch (e) {
          console.warn("resolveChannelDetails error", e);
        }
        return { author_url: null };
      }

      function apply_vid(vid) {
        console.log("apply_vid", vid);
        if (vid) {
          // Show parsed URL
          const parsedUrlContainer = document.getElementById("parsed-url-container");
          const parsedUrlInput = document.getElementById("parsed-url");
          const fullUrl = `https://www.youtube.com/watch?v=${vid}`;
          parsedUrlInput.value = fullUrl;
          parsedUrlContainer.style.display = "block";

          player.loadVideoById(vid);

          startSeek(100);

          setTimeout(async () => {
            const videoData = player.getVideoData();
            try {
              const details = await resolveChannelDetails(videoData.video_id);
              if (details?.author_url) videoData.author_url = details.author_url;
            } catch (e) {}
            addToHistory(videoData, document.title);
          }, 2000);
        }
      }

      function getHistory() {
        const history = JSON.parse(localStorage.getItem("history") || "[]");
        return history;
      }

      function addToHistory(videoData, name) {
        const history = getHistory();

        // Remove any existing entry with the same video_id
        const filteredHistory = history
          .filter((item) => item.videoData.video_id !== videoData.video_id);

        // Add the new entry to the front with timestamp
        const timestamp = new Date().toISOString();
        filteredHistory.unshift({ videoData, timestamp });
        localStorage.setItem("history", JSON.stringify(filteredHistory));

        console.log(history);

        renderHistory();
      }

      function renderVideoItem(videoData, timestamp, options = {}) {
        const {
          onRemove = null,
          removeButtonText = 'üóëÔ∏è',
          removeButtonTitle = 'Remove'
        } = options;
          const listItem = document.createElement("li");
          listItem.style.background = "#232323";
          listItem.style.borderRadius = "8px";
          listItem.style.margin = "12px auto";
          listItem.style.padding = "10px 16px";
          listItem.style.maxWidth = "480px";
          listItem.style.boxShadow = "0 2px 8px rgba(0,0,0,0.12)";
          listItem.style.display = "flex";
          listItem.style.flexDirection = "column";
          listItem.style.alignItems = "flex-start";
          listItem.style.gap = "4px";
          listItem.style.border = "1px solid #333";

          // Top row: author, id (clickable), play button
          const topRow = document.createElement("div");
          topRow.style.display = "flex";
          topRow.style.alignItems = "center";
          topRow.style.width = "100%";
          topRow.style.justifyContent = "space-between";

          const authorP = document.createElement("a");
          authorP.textContent = videoData.author;
          authorP.style.fontWeight = "bold";
          authorP.style.fontSize = "1rem";
          authorP.style.color = "#8ecae6";
          authorP.style.cursor = "pointer";
          authorP.style.textDecoration = "none";
          authorP.title = "Visit channel";

          // Set the href based on available data
          if (videoData.author_url) {
            authorP.href = videoData.author_url;
          } else if (videoData.author_id) {
            authorP.href = `https://www.youtube.com/channel/${videoData.author_id}`;
          } else {
            // Fallback: search for the channel
            authorP.href = `https://www.youtube.com/results?search_query=${encodeURIComponent(videoData.author)}`;
          }

          authorP.target = "_blank";
          authorP.rel = "noopener noreferrer";

          authorP.onmouseenter = () => {
            authorP.style.textDecoration = "underline";
            authorP.style.color = "#ffd166";
          };
          authorP.onmouseleave = () => {
            authorP.style.textDecoration = "none";
            authorP.style.color = "#8ecae6";
          };

          // id (clickable to open video)
          const idP = document.createElement("a");
          idP.textContent = videoData.video_id;
          idP.style.fontSize = "0.85rem";
          idP.style.color = "#bdbdbd";
          idP.style.fontFamily = "monospace";
          idP.style.marginLeft = "12px";
          idP.style.cursor = "pointer";
          idP.style.textDecoration = "none";
          idP.title = "Open video in new tab";
          idP.href = `https://www.youtube.com/watch?v=${videoData.video_id}`;
          idP.target = "_blank";
          idP.rel = "noopener noreferrer";

          idP.onmouseenter = () => {
            idP.style.textDecoration = "underline";
            idP.style.color = "#ffd166";
          };
          idP.onmouseleave = () => {
            idP.style.textDecoration = "none";
            idP.style.color = "#bdbdbd";
          };

          // Add timestamp if available
          const timestampSpan = document.createElement("span");
          if (timestamp) {
            const date = new Date(timestamp);
            const timeAgo = getTimeAgo(date);
            timestampSpan.textContent = timeAgo;
            timestampSpan.style.fontSize = "0.8rem";
            timestampSpan.style.color = "#888";
            timestampSpan.style.fontStyle = "italic";
            timestampSpan.style.marginLeft = "12px";
          }

          const playButton = document.createElement("button");
          playButton.textContent = "‚ñ∂Ô∏è";
          playButton.title = "Play";
          playButton.style.background = "#2d6a4f";
          playButton.style.color = "#fff";
          playButton.style.border = "none";
          playButton.style.borderRadius = "4px";
          playButton.style.padding = "4px 10px";
          playButton.style.cursor = "pointer";
          playButton.style.fontSize = "1.1em";
          playButton.style.marginLeft = "8px";
          playButton.onmouseenter = () => playButton.style.background = "#40916c";
          playButton.onmouseleave = () => playButton.style.background = "#2d6a4f";
          playButton.onclick = () => apply_input_vid(videoData.video_id);

          // Remove button (if onRemove callback provided)
          let removeButton = null;
          if (onRemove) {
            removeButton = document.createElement("button");
            removeButton.textContent = removeButtonText;
            removeButton.title = removeButtonTitle;
            removeButton.style.background = "#8b0000";
            removeButton.style.color = "#fff";
            removeButton.style.border = "none";
            removeButton.style.borderRadius = "4px";
            removeButton.style.padding = "4px 10px";
            removeButton.style.cursor = "pointer";
            removeButton.style.fontSize = "1.1em";
            removeButton.style.marginLeft = "8px";
            removeButton.onmouseenter = () => removeButton.style.background = "#a00000";
            removeButton.onmouseleave = () => removeButton.style.background = "#8b0000";
            removeButton.onclick = () => onRemove(videoData.video_id);
          }

          // Expand/Collapse button
          const expandBtn = document.createElement("button");
          expandBtn.textContent = "‚ñæ";
          expandBtn.title = "Expand channel videos";
          expandBtn.style.background = "#3a3a3a";
          expandBtn.style.color = "#fff";
          expandBtn.style.border = "none";
          expandBtn.style.borderRadius = "4px";
          expandBtn.style.padding = "4px 10px";
          expandBtn.style.cursor = "pointer";
          expandBtn.style.fontSize = "1.1em";
          expandBtn.style.marginLeft = "8px";
          expandBtn.onmouseenter = () => expandBtn.style.background = "#4a4a4a";
          expandBtn.onmouseleave = () => expandBtn.style.background = "#3a3a3a";

          // Assemble top row
          const leftGroup = document.createElement("span");
          leftGroup.style.display = "flex";
          leftGroup.style.alignItems = "center";
          leftGroup.appendChild(authorP);
          leftGroup.appendChild(idP);
          if (timestamp) {
            leftGroup.appendChild(timestampSpan);
          }

          topRow.appendChild(leftGroup);
          const rightGroup = document.createElement("span");
          rightGroup.appendChild(playButton);
          if (removeButton) rightGroup.appendChild(removeButton);
          rightGroup.appendChild(expandBtn);
          topRow.appendChild(rightGroup);

          // Title row
          const titleP = document.createElement("span");
          titleP.textContent = videoData.title;
          titleP.style.fontSize = "1.05rem";
          titleP.style.fontWeight = "500";
          titleP.style.color = "#fff";
          titleP.style.marginTop = "2px";
          titleP.style.marginBottom = "2px";
          titleP.style.wordBreak = "break-word";

          // Expandable container for latest videos
          const expandContainer = document.createElement("div");
          expandContainer.style.display = "none";
          expandContainer.style.width = "100%";
          expandContainer.style.marginTop = "6px";
          expandContainer.style.padding = "8px 10px";
          expandContainer.style.background = "#1c1c1c";
          expandContainer.style.border = "1px solid #333";
          expandContainer.style.borderRadius = "6px";
          expandContainer.style.boxSizing = "border-box";

          const expandStatus = document.createElement("div");
          expandStatus.style.color = "#bbb";
          expandStatus.style.fontSize = "0.9rem";
          expandStatus.textContent = "Loading...";
          expandContainer.appendChild(expandStatus);

          async function toggleExpand() {
            const isOpen = expandContainer.style.display !== "none";
            if (isOpen) {
              expandContainer.style.display = "none";
              expandBtn.textContent = "‚ñæ";
              expandBtn.title = "Expand channel videos";
              return;
            }
            expandContainer.style.display = "block";
            // Placeholder UI only; fetching disabled for now
            expandStatus.textContent = "Channel videos placeholder (fetching disabled).";
            expandBtn.textContent = "‚ñ¥";
            expandBtn.title = "Collapse";
            // Intentionally do not fetch latest videos; keep placeholder visible
            return;
          }

          expandBtn.onclick = toggleExpand;

          // Assemble
          listItem.appendChild(topRow);
          listItem.appendChild(titleP);
          listItem.appendChild(expandContainer);

          return listItem;
      }

      function renderHistory() {
        history_list.innerHTML = "";
        const history = getHistory();
        console.log("renderHistory", history);

        history.forEach(({ videoData, timestamp }) => {
          const listItem = renderVideoItem(videoData, timestamp, {
            onRemove: (videoId) => {
              // Remove from history
              const history = getHistory();
              const filtered = history.filter(item => item.videoData.video_id !== videoId);
              localStorage.setItem("history", JSON.stringify(filtered));
              renderHistory();
            }
          });
          history_list.appendChild(listItem);
        });
      }

      function clearHistory() {
        console.log("clearHistory");
        localStorage.removeItem("history");
        renderHistory();
      }

      const switchWidthBtn = document.getElementById("switch-width-btn");
      let isFullWidth = true;

      const handleViewportChange = () => setFullWidth(false);

      function setFullWidth(full) {
        if (full) {
          ytplayer.style.width = "100%";
          timeline.style.width = "100%";
          ytplayer.style.margin = "";
          ytplayer.style.position = "";
          ytplayer.style.left = "";
          ytplayer.style.transform = "";
          timeline.style.margin = "";
          timeline.style.position = "";
          timeline.style.left = "";
          timeline.style.transform = "";
          timelineTime.style.position = "";
          timelineTime.style.left = "";
          timelineTime.style.width = "";
          switchWidthBtn.textContent = "Viewport";
        } else {
          // Use viewport dimensions and position, accounting for zoom and scroll
          const viewportWidth = window.visualViewport.width;
          const viewportLeft = window.visualViewport.offsetLeft;

          // Set width to viewport width
          ytplayer.style.width = viewportWidth + "px";
          timeline.style.width = viewportWidth + "px";

          // Position elements to be centered in the current viewport
          ytplayer.style.position = "relative";
          ytplayer.style.left = viewportLeft + "px";
          ytplayer.style.margin = "0";

          timeline.style.position = "relative";
          timeline.style.left = viewportLeft + "px";
          timeline.style.margin = "10px 0";

          timelineTime.style.position = "relative";
          timelineTime.style.left = viewportLeft + "px";
          timelineTime.style.width = viewportWidth + "px";

          switchWidthBtn.textContent = "Full";
        }
        isFullWidth = full;
      }

      switchWidthBtn.onclick = function() {
        const newFullWidth = !isFullWidth;
        setFullWidth(newFullWidth);

        if (newFullWidth) {
          window.visualViewport.removeEventListener("resize", handleViewportChange);
          window.visualViewport.removeEventListener("scroll", handleViewportChange);
        } else {
          window.visualViewport.addEventListener("resize", handleViewportChange);
          window.visualViewport.addEventListener("scroll", handleViewportChange);
        }
      };

      // Set initial state
      setFullWidth(true);

    </script>
    <script src="https://alcdn.msauth.net/browser/2.38.0/js/msal-browser.min.js"></script>
    <script>
      // Microsoft identity platform (MSAL) bootstrap for SPA
      // Using F# app registration clientId and consumers tenant (no secret)
      // Auto-detect redirect URI based on environment
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      const redirectUri = isLocalhost
        ? `http://${window.location.hostname}:8000/youtube.html`
        : 'https://rutgersc.github.io/youtube.html';

      const msalConfig = {
        auth: {
          clientId: '57f0a441-626f-433e-b375-0c81f1203567',
          authority: 'https://login.microsoftonline.com/consumers',
          redirectUri: redirectUri
        },
        cache: { cacheLocation: 'localStorage', storeAuthStateInCookie: false }
      };
      const msalScopes = ['openid', 'profile', 'offline_access', 'User.Read', 'Tasks.ReadWrite'];
      const msalInstance = new msal.PublicClientApplication(msalConfig);

      function updateMsalUi() {
        const btn = document.getElementById('msal-login-btn');
        const status = document.getElementById('msal-login-status');
        const userInfo = document.getElementById('msal-user-info');
        const userName = document.getElementById('msal-user-name');
        const userEmail = document.getElementById('msal-user-email');
        if (!btn || !status) return;
        const account = msalInstance.getActiveAccount();
        if (account) {
          btn.textContent = 'Sign out';
          btn.style.color = '#ff6b6b';
          status.textContent = 'Signed in';

          // Log complete user info to console
          console.log('=== MSAL User Account Info ===');
          console.log('Complete account object:', account);
          console.log('Name:', account.name);
          console.log('Username:', account.username);
          console.log('Local Account ID:', account.localAccountId);
          console.log('Home Account ID:', account.homeAccountId);
          console.log('Environment:', account.environment);
          console.log('Tenant ID:', account.tenantId);
          console.log('ID Token Claims:', account.idTokenClaims);
          console.log('==============================');

          // Show user info
          if (userInfo && userName && userEmail) {
            userName.textContent = account.name || 'User';
            userEmail.textContent = account.username || '';
            userInfo.style.display = 'block';
          }

          // Initialize watch later when signed in
          if (!watchLaterTaskId) {
            initWatchLater().catch(e => console.error('Failed to init watch later:', e));
          }
        } else {
          btn.textContent = 'Sign in';
          btn.style.color = '#8ecae6';
          status.textContent = 'Signed out';

          // Hide user info
          if (userInfo) {
            userInfo.style.display = 'none';
          }
        }
      }

      async function msalLogin() {
        try {
          const res = await msalInstance.loginPopup({ scopes: msalScopes });
          msalInstance.setActiveAccount(res.account);
          updateMsalUi();
        } catch (e) {
          console.warn('loginPopup failed', e);
        }
      }

      async function msalLogout() {
        try {
          const account = msalInstance.getActiveAccount();
          await msalInstance.logoutPopup({ account });
          updateMsalUi();
        } catch (e) {
          console.warn('logoutPopup failed', e);
        }
      }

      async function msalAcquireGraphToken() {
        const account = msalInstance.getActiveAccount();
        try {
          if (!account) throw new Error('No signed-in account');
          const res = await msalInstance.acquireTokenSilent({ scopes: msalScopes, account });
          return res.accessToken;
        } catch (e) {
          const res = await msalInstance.acquireTokenPopup({ scopes: msalScopes });
          msalInstance.setActiveAccount(res.account);
          updateMsalUi();
          return res.accessToken;
        }
      }

      // Expose helper for other scripts to call Graph easily
      window.msalAcquireGraphToken = msalAcquireGraphToken;

      // Microsoft To Do / Graph API helpers
      async function callGraphApi(endpoint, method = 'GET', body = null) {
        try {
          const token = await msalAcquireGraphToken();
          const headers = {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          };
          const options = {
            method,
            headers
          };
          if (body) {
            options.body = JSON.stringify(body);
          }
          const response = await fetch(`https://graph.microsoft.com/v1.0${endpoint}`, options);
          if (!response.ok) {
            throw new Error(`Graph API error: ${response.status} ${response.statusText}`);
          }
          return await response.json();
        } catch (e) {
          console.error('callGraphApi error:', e);
          throw e;
        }
      }

      async function getAppStateTodoList() {
        try {
          console.log('Fetching todo lists...');
          const lists = await callGraphApi('/me/todo/lists');
          console.log('All todo lists:', lists);

          // Find the "appstate" list
          const appStateList = lists.value.find(list => list.displayName.toLowerCase() === 'appstate');

          if (appStateList) {
            console.log('Found appstate list:', appStateList);
            return appStateList;
          } else {
            console.log('appstate list not found, creating it...');
            // Create the list if it doesn't exist
            const newList = await callGraphApi('/me/todo/lists', 'POST', {
              displayName: 'appstate'
            });
            console.log('Created appstate list:', newList);
            return newList;
          }
        } catch (e) {
          console.error('getAppStateTodoList error:', e);
          throw e;
        }
      }

      async function getAppStateTasks(listId) {
        try {
          console.log('Fetching tasks from appstate list...');
          const tasks = await callGraphApi(`/me/todo/lists/${listId}/tasks`);
          console.log('appstate tasks:', tasks);
          return tasks.value;
        } catch (e) {
          console.error('getAppStateTasks error:', e);
          throw e;
        }
      }

      async function createAppStateTask(listId, title, body = '') {
        try {
          const task = await callGraphApi(`/me/todo/lists/${listId}/tasks`, 'POST', {
            title: title,
            body: {
              content: body,
              contentType: 'text'
            }
          });
          console.log('Created task:', task);
          return task;
        } catch (e) {
          console.error('createAppStateTask error:', e);
          throw e;
        }
      }

      async function updateAppStateTask(listId, taskId, title, body) {
        try {
          const task = await callGraphApi(`/me/todo/lists/${listId}/tasks/${taskId}`, 'PATCH', {
            title: title,
            body: {
              content: body,
              contentType: 'text'
            }
          });
          console.log('Updated task:', task);
          return task;
        } catch (e) {
          console.error('updateAppStateTask error:', e);
          throw e;
        }
      }

      // Watch Later functionality using Microsoft To Do checklist items
      let watchLaterTaskId = null;
      let watchLaterListId = null;
      let initWatchLaterPromise = null;

      async function initWatchLater() {
        // Prevent multiple simultaneous initializations
        if (initWatchLaterPromise) {
          return initWatchLaterPromise;
        }

        initWatchLaterPromise = (async () => {
          try {
            const list = await getAppStateTodoList();
            watchLaterListId = list.id;

            const tasks = await getAppStateTasks(list.id);
            let watchLaterTask = tasks.find(t => t.title === 'youtube-watch');

            if (!watchLaterTask) {
              console.log('Creating youtube-watch task...');
              watchLaterTask = await createAppStateTask(list.id, 'youtube-watch', 'Videos to watch later');
            }

            watchLaterTaskId = watchLaterTask.id;
            console.log('Watch later task initialized:', watchLaterTask);
            console.log('Task ID:', watchLaterTask.id);
            console.log('Task title:', watchLaterTask.title);

            // Fetch full task details to see if there are steps
            const fullTask = await callGraphApi(`/me/todo/lists/${watchLaterListId}/tasks/${watchLaterTaskId}`);
            console.log('Full task details:', fullTask);

            await loadWatchLater();
          } catch (e) {
            console.error('initWatchLater error:', e);
            document.getElementById('watch-later-status').textContent = 'Error loading watch later list';
            initWatchLaterPromise = null; // Allow retry on error
            throw e;
          }
        })();

        return initWatchLaterPromise;
      }

      async function getWatchLaterChecklistItems() {
        try {
          console.log('Fetching checklist items from API...');
          console.log('URL:', `/me/todo/lists/${watchLaterListId}/tasks/${watchLaterTaskId}/checklistItems`);
          const response = await callGraphApi(`/me/todo/lists/${watchLaterListId}/tasks/${watchLaterTaskId}/checklistItems`);
          console.log('Raw API response:', response);
          console.log('Response.value:', response.value);
          return response.value || [];
        } catch (e) {
          console.error('getWatchLaterChecklistItems error:', e);
          return [];
        }
      }

      async function removeFromWatchLater(checklistItemId) {
        try {
          await callGraphApi(
            `/me/todo/lists/${watchLaterListId}/tasks/${watchLaterTaskId}/checklistItems/${checklistItemId}`,
            'DELETE'
          );
          console.log('Removed from watch later:', checklistItemId);
          await loadWatchLater();
        } catch (e) {
          console.error('removeFromWatchLater error:', e);
        }
      }

      async function loadWatchLater() {
        const watchLaterList = document.getElementById('watch_later_list');
        const watchLaterStatus = document.getElementById('watch-later-status');

        console.log('=== Load Watch Later Debug ===');
        console.log('watchLaterListId:', watchLaterListId);
        console.log('watchLaterTaskId:', watchLaterTaskId);
        console.log('initWatchLaterPromise:', initWatchLaterPromise);

        try {
          if (!watchLaterTaskId) {
            console.log('No watchLaterTaskId, initializing...');
            await initWatchLater();
            return;
          }

          watchLaterStatus.textContent = 'Loading...';
          const items = await getWatchLaterChecklistItems();

          console.log('Loaded checklist items:', items);
          console.log('Number of items:', items.length);

          watchLaterList.innerHTML = '';
          watchLaterStatus.style.display = 'none';

          if (items.length === 0) {
            console.log('No items to display');
            watchLaterStatus.textContent = 'No videos in watch later';
            watchLaterStatus.style.display = 'block';
            return;
          }

          // Render items with embedded metadata
          for (const item of items) {

            let videoData;
            try {
              // Try to parse as JSON (new format with embedded metadata)
              videoData = JSON.parse(item.displayName);
              if (!videoData.video_id) {
                throw new Error('No video_id in parsed data');
              }
            } catch (e) {
              // Fallback: treat displayName as plain video ID (old format)
              const videoId = extractYouTubeId(item.displayName) || item.displayName;
              videoData = {
                video_id: videoId,
                title: 'Loading...',
                author: 'Loading...',
                author_url: null
              };
            }

            const listItem = renderVideoItem(videoData, null, {
              onRemove: (vid) => removeFromWatchLater(item.id)
            });
            watchLaterList.appendChild(listItem);

            // If missing metadata, fetch it asynchronously to update the already-rendered item
            if (!videoData.title || videoData.title === 'Loading...') {
              const videoId = videoData.video_id;
              (async () => {
                try {
                  const cacheKey = `videoMetadata:${videoId}`;
                  let metadata = localStorage.getItem(cacheKey);

                  if (!metadata) {
                    const res = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`);
                    if (res.ok) {
                      const data = await res.json();
                      metadata = JSON.stringify({
                        title: data.title,
                        author: data.author_name,
                        author_url: data.author_url
                      });
                      localStorage.setItem(cacheKey, metadata);
                    }
                  }

                  if (metadata) {
                    const data = JSON.parse(metadata);
                    const titleEl = listItem.querySelector('span[style*="font-weight: 500"]');
                    const authorEl = listItem.querySelector('a[style*="font-weight: bold"]');
                    if (titleEl) titleEl.textContent = data.title || 'Unknown title';
                    if (authorEl) {
                      authorEl.textContent = data.author || 'Unknown author';
                      if (data.author_url) authorEl.href = data.author_url;
                    }
                  }
                } catch (e) {
                  console.warn('Failed to fetch metadata for', videoId, e);
                }
              })();
            }
          }

          console.log('Successfully rendered', items.length, 'items');
          console.log('==============================');

        } catch (e) {
          console.error('loadWatchLater error:', e);
          console.log('==============================');
          watchLaterStatus.textContent = 'Error loading watch later';
          watchLaterStatus.style.display = 'block';
        }
      }

      // Expose functions globally for testing
      window.getAppStateTodoList = getAppStateTodoList;
      window.getAppStateTasks = getAppStateTasks;
      window.createAppStateTask = createAppStateTask;
      window.updateAppStateTask = updateAppStateTask;
      window.loadWatchLater = loadWatchLater;
      window.initWatchLater = initWatchLater;

      // Handle redirect responses if any, then set initial UI state
      msalInstance.handleRedirectPromise()
        .then((response) => {
          if (response && response.account) {
            msalInstance.setActiveAccount(response.account);
          } else {
            const accounts = msalInstance.getAllAccounts();
            if (accounts && accounts.length > 0) {
              msalInstance.setActiveAccount(accounts[0]);
            }
          }
        })
        .catch((err) => console.warn('handleRedirectPromise error', err))
        .finally(() => {
          updateMsalUi();
        });

      // Wire up the floating button
      document.addEventListener('DOMContentLoaded', function() {
        const btn = document.getElementById('msal-login-btn');
        if (btn) {
          btn.onclick = function() {
            const account = msalInstance.getActiveAccount();
            if (account) {
              msalLogout();
            } else {
              msalLogin();
            }
          };
        }
        updateMsalUi();
      });
    </script>
  </body>
</html>